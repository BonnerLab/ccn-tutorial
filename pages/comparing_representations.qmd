---
title: Comparing neural representations
subtitle: Cross-validated methods to separate high-dimensional signal from noise
abstract: Especially after the advent of high-dimensional neural network models of the brain, there has been an explosion of methods to compare high-dimensional representations, including various forms of linear regression, canonical correlation analysis (CCA), centered kernel alignment (CKA), and non-linear methods too! In this part of the tutorial, we'll describe PLS-SVD -- a method closely related to PCA -- that allows us to measure the similarity between two high-dimensional systems in a manner that is relatively interpretable and extensible for various purposes.
---

::: {.content-visible when-format="html"}

::: {.callout-tip}
# Run this notebook interactively!

Here's a [link to this notebook](https://colab.research.google.com/github/BonnerLab/ccn-tutorial/blob/main/notebooks/comparing_representations.ipynb) on Google Colab.
:::

:::

## Invariances

Comparing different representations of the same stimuli is integral to the study of sensory neuroscience. Every computational model of a system must be effectively related to experimental data for validation. A key question to keep in mind when comparing representations is the set of invariances we would like to preserve.

For example, take the CCN logo:

If we translate it, it retains its "fundamental" structure -- what makes it the CCN logo. If we rotate it, 
When comparing two representations

![](/resources/transformations.svg)

## Cross-decomposition

Just as PCA identifies the principal directions of variance of a system, *cross-decomposition* identifies the principal directions of *shared* variance between *two* systems $X$ and $Y$. Specifically, just as PCA computes the eigendecomposition of the auto-covariance, cross-decomposition computes the singular value decomposition of the cross-covariance:

$$
\begin{align*}
    \text{cov}(X, Y)
    &= X^\top Y / (n - 1)\\
    &= U \Sigma V^\top
\end{align*}
$$

[Note that $X$ and $Y$ have been centered, as usual.]{.aside}

Here,

- the left singular vectors $U$ define a rotation of the system $X$ into a latent space
- the right singular vectors $V$ define a rotation of system $Y$ into the *same* latent space, and
- the singular values $\Sigma$ define the amount of variance shared by the two systems along the latent dimensions.

::: {.column-page}
![](/resources/cross-covariance-svd.svg){width=100%}
:::

::: {.callout-note}
# A note on terminology

The cross-decomposition method we describe here is more specifically known as [Partial Least Squares Singular Value Decomposition (PLS-SVD)](https://scikit-learn.org/stable/modules/generated/sklearn.cross_decomposition.PLSSVD.html). We simplify it to "cross-decomposition" since we will be developing a cross-validated version of the typical estimators.
:::

::: {.callout-note}
# What happens when $X$ = $Y$?

Note that if $X = Y$, cross-decomposition reduces to PCA:

:::

{{< include _code/install_package.qmd >}}

```{python}
# | label: imports
# | code-summary: Import various libraries

from collections.abc import Sequence
import warnings

import numpy as np
import pandas as pd
import xarray as xr
import torch
from torchdata.datapipes.map import SequenceWrapper
from torchvision.models import alexnet, AlexNet_Weights
from sklearn.decomposition import TruncatedSVD, PCA
from PIL import Image
import seaborn as sns
import matplotlib as mpl
from matplotlib import pyplot as plt
from matplotlib_inline.backend_inline import set_matplotlib_formats
from IPython.display import display

from utilities.brain import (
    load_dataset,
    average_data_across_repetitions,
    load_stimuli,
    plot_brain_map,
)
from utilities.computation import svd, assign_logarithmic_bins
from utilities.model import (
    extract_features,
    SparseRandomProjection,
    create_image_datapipe,
)

```

{{< include _code/set_visualization_defaults.qmd >}}

{{< include _code/initialize_rng.qmd >}}

```{python}
# | label: recipe-plssvd
# | code-summary: A computational recipe for PLS-SVD
# | code-fold: show
# | echo: true


class PLSSVD:
    def __init__(self) -> None:
        self.left_mean: np.ndarray
        self.right_mean: np.ndarray
        self.left_singular_vectors: np.ndarray
        self.right_singular_vectors: np.ndarray

    def fit(self, /, x: np.ndarray, y: np.ndarray) -> None:
        self.left_mean = x.mean(axis=-2)  # <1>
        self.right_mean = y.mean(axis=-2)  # <1>

        x_centered = x - self.left_mean  # <1>
        y_centered = y - self.right_mean  # <1>

        n_stimuli = x.shape[-2]

        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        cross_covariance = (np.swapaxes(x_centered, -1, -2) @ y_centered) / (
            n_stimuli - 1
        )  # <2>

        (
            self.left_singular_vectors,
            self.singular_values,
            self.right_singular_vectors,
        ) = svd(
            torch.from_numpy(cross_covariance).to(device),
            n_components=min([*x.shape, *y.shape]),
            truncated=True,
            seed=random_state,
        )  # <3>

        self.left_singular_vectors = self.left_singular_vectors.cpu().numpy()
        self.singular_values = self.singular_values.cpu().numpy()
        self.right_singular_vectors = self.right_singular_vectors.cpu().numpy()

    def transform(self, /, z: np.ndarray, *, direction: str) -> np.ndarray:
        match direction:
            case "left":
                return (z - self.left_mean) @ self.left_singular_vectors  # <4>
            case "right":
                return (z - self.right_mean) @ self.right_singular_vectors  # <4>
            case _:
                raise ValueError("direction must be 'left' or 'right'")


```

1. Center the data matrices $X$ and $Y$.
2. Compute their cross-covariance $X^\top Y / (n - 1)$.
3. Compute the [singular value decomposition](reference.qmd#singular-value-decomposition) of the cross-covariance.
4. To project data from the ambient space ($X$ or $Y$) to the latent space, we must subtract the mean computed in Step 1, and multiply the data by the corresponding singular vectors.

## Comparing brains

In the same way that we can **cross-validated PCA** to estimate the shared variance across presentations of the same stimuli *within* a participant, we can use **cross-decomposition** to estimate the shared variance in the neural representations of the same stimuli *across* participants.

We have two data matrices $X \in \mathbb{R}^{N \times P_X}$ and $Y \in \mathbb{R}^{N \times P_Y}$ from two participants. We could directly compute the singular values of their cross-covariance, which would be a direct estimate of the shared variance between these two representations.

However, we run into the same issue as before: the singular values of a matrix are always positive and we won't be able to use the magnitude of the singular value to assess the reliability of the variance along that dimension.

Instead, we can use a cross-validated approach similar to CV-PCA, except that instead of testing generalization across different *presentations* of the stimuli, we can evaluate the reliable shared variance between the two representations across *stimuli*.

Specifically, we can divide the images into two: a training split and a test split. We can compute singular vectors on the training split, and evalute *test* singular values on the test split, analogous to the CV-PCA procedure:

::: {.column-page}
![](/resources/pls_svd.svg){width=100%}
:::

$$
\begin{align*}
    \text{cov}(X_\text{train}, Y_\text{train})
    &= X_\text{train}^\top Y_\text{train} / (n - 1)\\
    &= U \Sigma V^\top\\
    \\
    \Sigma_\text{cross-validated}
    &= \text{cov}(X_\text{train} U, Y_\text{test} V)\\
    &= \left( X_\text{train} U \right) ^\top \left( Y_\text{test} V \right) / (n - 1)
\end{align*}
$$

```{python}
# | code-summary: Load the datasets

subject_1 = average_data_across_repetitions(
    load_dataset(subject=0, roi="general")
).sortby("stimulus_id")
subject_2 = average_data_across_repetitions(load_dataset(subject=1, roi="general"))

stimuli = load_stimuli()["stimulus_id"].values

display(subject_1)
display(subject_2)
```


```{python}
# | code-summary: Compute the cross-participant spectrum


def compute_cross_validated_spectrum(
    x: xr.DataArray,
    y: xr.DataArray,
    /,
    train_fraction: float = 7 / 8,
) -> np.ndarray:
    stimuli = x["stimulus_id"].values
    n_train = int(train_fraction * len(stimuli))
    stimuli = rng.permutation(stimuli)[:n_train]

    train_indices = np.isin(x["stimulus_id"].values, stimuli)

    x_train = x.isel({"presentation": train_indices})
    y_train = y.isel({"presentation": train_indices})

    x_test = x.isel({"presentation": ~train_indices})
    y_test = y.isel({"presentation": ~train_indices})

    scorer = PLSSVD()
    scorer.fit(x_train.values, y_train.values)
    x_test_transformed = scorer.transform(x_test.values, direction="left")
    y_test_transformed = scorer.transform(y_test.values, direction="right")

    return np.diag(
        np.cov(
            x_test_transformed,
            y_test_transformed,
            rowvar=False,
        )[:n_train, n_train:]
    )


spectrum = compute_cross_validated_spectrum(subject_1, subject_2)

data = pd.DataFrame(
    {
        "cross-validated singular value": spectrum,
        "rank": assign_logarithmic_bins(
            1 + np.arange(len(spectrum)), min_=1, max_=10_000, points_per_bin=5
        ),
    }
)

fig, ax = plt.subplots()
sns.lineplot(
    ax=ax,
    data=data,
    x="rank",
    y="cross-validated singular value",
    marker="o",
    dashes=False,
    ls="None",
    err_style="bars",
    estimator="mean",
    errorbar=("ci", 99),
)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_aspect("equal", "box")
sns.despine(ax=ax, offset=20)
```

## Comparing brains and DNNs

```{python}
# | label: load-model
# | code-summary: Load an ImageNet-trained convolutional neural network (AlexNet)

weights = AlexNet_Weights.DEFAULT

model = alexnet(weights=weights)
model.eval()
```

```{python}
# | label: create-datapipe
# | code-summary: Prepare stimuli

stimulus_set = load_stimuli().load()
datapipe = create_image_datapipe(
    SequenceWrapper(
        {
            str(stimulus["stimulus_id"].values): Image.fromarray(stimulus.values)
            for stimulus in stimulus_set
        }
    ),
    batch_size=128,
    preprocess_fn=weights.transforms(),
    indices=list(stimulus_set["stimulus_id"].values),
)
```

```{python}
# | label: extract-features
# | code-summary: Extract AlexNet activations to the stimuli

layers = [f"features.{i}" for i in (1, 4, 7, 9, 11)]
postprocess_hook = SparseRandomProjection(n_components=2000)

features = extract_features(
    model=model,
    model_identifier="AlexNet-ImageNet1KV1",
    nodes=layers,
    hooks={layer: postprocess_hook for layer in layers},
    datapipe=datapipe,
    datapipe_identifier="natural_scenes_dataset",
    use_cached=False,
)
```

```{python}
# | code-summary: Compute cross-covariance between one participant and the convolutional layers of AlexNet

spectra = {}
for layer, activations in features.items():
    spectra[layer] = compute_cross_validated_spectrum(subject_1, subject_2)

remapping = {
    "features.1": "conv1",
    "features.4": "conv2",
    "features.7": "conv3",
    "features.9": "conv4",
    "features.11": "conv5",
}

fig, ax = plt.subplots()
sns.lineplot(
    ax=ax,
    data=(
        pd.DataFrame(spectra)
        .rename(columns=remapping)
        .assign(
            rank=lambda x: assign_logarithmic_bins(
                1 + np.arange(len(x)), points_per_bin=3, min_=1, max_=10_000
            )
        )
        .melt(
            id_vars=["rank"],
            value_name="cross-validated singular value",
            var_name="layer",
        )
    ),
    x="rank",
    y="cross-validated singular value",
    hue="layer",
    marker="o",
    dashes=False,
    ls="None",
    err_style="bars",
    estimator="mean",
    errorbar=("ci", 99),
)
ax.set_xscale("log")
ax.set_yscale("log")
ax.set_aspect("equal", "box")
sns.despine(ax=ax, offset=20)
```
